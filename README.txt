



int s = socket(domain,	type, protocol);	

s - дескриптор сокета
дескриптор - подобие указателя на сущность ядра
зависит от конкретного приложения (в разных приложениях могут
использоваться сокеты с одинаковыми дескрипторами (его номер уникален
только в рамках приложения)) 


domain:
	AF_INET - IPv4
	AF_INET6 - IPv6
	AF_UNIX

type:
	SOCK_STREAM - TCP
	DGRAM	- 	UDP

protocol:
	= 0 // протокол по умолчанию
	IPPROTO_TCP/UDP

после создания сокета его нужно привязать к IP-адресу и порту,
на который открывается сокет
для клиентских - это IP сервера и порт, к которому нужно присоединиться

bind(s, (struct SockAddr*) &sa, sizeof(sa));

struct sockAddr_in sa;
sa.sin_family = AF_INET; // указываем domain
sa.sin_port = htons();
sa.sin_addr.s_addr = htonl(INADDR_LOOPBACK);

// htons() - приводит число к сетевому порядку байт
INADDR_LOOPBACK - (127.0.0.1) - наша машина
если мы запустили серв под этим адресом, то подключиться к нему могут лишь
те клиенты, которые запущены на той же машине, что и сервер
(верно и обратное - для клиентов)
INADDR_ANY - (0.0.0.0) - открывается на все доступные адреса сразу
// htonl(INADDR_LOOPBACK) - приводит к сетевому же порядку байт

устаревшая: ip = inet_addr("10.0.0.1");
			   = inet_pton(AF_INET, "", &(sa.sin_addr);

unix-sockets:
	struct sockaddr_un sa;
	sa.sun_family = AF_UNIX;
	strcpy(sa.sun_path, "/tmp/a.sock");
	// создали unix-сокет в папке tmp (хороший тон)


// сокет привязан к адресу, теперь нужно его слушать

listen(s, SOMAXCONN);
// мы можем принимать <= 1 соединение за раз
// если соединений много, то они встаю в очередь
// SOMAXCONN - максимальная длина очереди в д. ОС (обычно 128)


// начинаем принимать соединения
while(s1 == accept(s, (struct sockAddr*) - IP и порт клинета
	= NULL, size = 0))	{
	s1 - сокет
}

после того, как соединение установлено, начинаем обмениваться
данными

size_t read (int fd (в д. сл-е сокет), void* buf - куда читаем
	, size_t count - сколько читаем);
size_t write (int fd, const void* buf, size_t count);

если применим к сокету, они будут работать, но если мы попытаемся
читать/записывать в сокет, соединение по которому оборвано, ось выдаст
сообщение SIGPIPE

	можем сообщение игнорить: singnal(SIGPIPE, SIG_IGN);
	лучше сделать так, чтобы SIGPIPE не приходил вообще:

size_t recv (int fd (в д. сл-е сокет), void* buf - куда читаем
	, size_t count - сколько читаем);
size_t send (int fd, const void* buf, size_t count);

мультиплексирование
веб-чат - один слушающий сокет и много подключенных, сообщение от
одного клиента нужно передать всем остальным

1 мастер-сокет - много slave

4 способа:
1- системный вызов select
(для чего он нужен, почему не опрашивать целиком, не проводиьт  read в неблокирующем режиме - потому что будет нагревать процессор)

создать множество сокетов

fd_set set; // 1024 бита (0 || 1)
все фд, помещенные туда, имеют номер 1
только 1024 фд

FD_ZERO(&set); // занулить
FD_SET(master_socket, &set); // добавили master_socket, чтобы принимать соединения 

for (...)	{ FD_SET(*iter, &set);// добавляем все slaves	}

далее нужно определить индекс самого большого сокета
- мы должны знать, где последний бит, чтобы не пробегать все 1024 бита,
а бежать только до последнего

int max = (...) - максимальный дескриптор

select(max + 1, &set - set дескрипторов которые слушаем на чтение, NULL - на запись, NULL - на ошибку, NULL - таймаут (если мы хотим чтобы сокет не всегда дердал процессор, а иногда отпускал, то можно указать ему на какое время отпустить));

далее проверяем slave-ы, не пришло ли чего

for (..) { if (FD_ISSET(*iter, &set)) {
				...
			}
			if (FD_ISSET(master_socket, &set)) { accept }
}

есть ядро, мы собираем FD_SET и выставляем единички в те сокеты, которые надо проверить
отправлили в ядро, процесс уснул, пришла инфа что можно считать из таких-то сокетов (единицы) процесс проснулся, ему вернулся FD_SET, в котором отмечены единицами только те сокеты, из которых можно читать

2 - poll отличается тем, что стирается ограничение на 1024 дескритора, однако
между ядром и приложением будем гонять куда большие объемы данных

struct pollfd set[POLL_SIZE]; // 1 + max число slave
set[0].fd = master_socket;
set[0].events = POLLIN; // отслеживаем то, что читаем

// все slave

poll(set, set_size - число элементов, -1 - вечный таймаут);

for (...)	{
	if (set[i].revents & POLLIN) {
		...
	}
}


и в select и в poll есть проблема -
есть ядро, и в него мы передаем множетсво сокетов (копируем инфу в ядро),
там происходит какая-то
работа, и данные возвращаются в том же объеме. Для select - сработал или нет
( 1 или 0), в случае poll возвращается заданный объем, в котором флаги установлены по-другому (биты)
в любом случае мы гоняем довольно много инфы туда и обратно
каждый раз
более того, когда к нам приходит инфа мы ее должные еще всю пробежать и проверить


3 - 
хотелось бы создать объект ядра
прямо в ядро добавить дескриптор
и там же спросить, где происходит событие
и нам вернется несколько дескрипторов, где событие происходит
этом механизм существует, и решает проблему С10К (10.000 соединений)
 в линуксе называется EPOLL а в FreeBSD KQ

int EPoll = epoll_create1(0); // создали дескриптор

struct epoll_event event; 
event.data.fd = master_seocket;
event.events = EPOLLIN | EPOLLET;

есть 2 способа работы epoll
1 - возвращает событие тогда, когда данные мы еще не прочитали
2 - возвращает тогда, когда есть новые данные (второе событие не придет,
пока не прочитаем первую пачку данных)

epoll_ctl(EPoll, EPOLL_CTL_ADD, master_socket, &event); // зарег. событиие

struct epoll_event events[A];

while(1)	{
	int N = epoll_wait(EPoll, events, A, -1); // можем получить до А событий
	N - сколько конкретно событий вернулось в этот раз (мб и 0)
	for(.< N..)	{
		 if (events[i].events & EPOLLERR ||
		 events[i].events & EPOLLHUP - разрыв соединения)
		 {
		 }
	}
}

4 - KQ (freeBSD macOS
чуть-чуть лучшу epoll

есть ядро и список сокетов в ядре
мы, сделав единственный системный вызов можем
добавить/убрать несоклько сокетов (одновременно)
и одновременно получить все события
- все за 1 сис. вызов

int KQueue = kqueue();
struct Kevent Kevent;
bzero(&Kevent, sizeof(Kevent)); // очистили
EV_SET(&Kevent, master_soket, EVFILT_READ, EV_ADD, 0, 0, 0);
kevent(KQueue, &Kevent, 1 (можно и не 1 event), NULL, 0,
NULL - таймаут);

while(1)	{
	bzero(&Kevent, sizeof(Kevent));
	kevent(KQueue, NULL, 0, &Kevent, 1, NULL);
	if (Kevent.filter == EVFILT_READ) {...}
	}	
